# 进制&位运算
## 1.进制介绍
对于整数有4种表达方式
* 二进制:`0,1`;以`0b`或`0B`开头,`int n = 0b1010;`
* 十进制:`0-9`;`int n = 1010`
* 八进制:`0-7`;以`0`开头,`int n = 01010;`
* 十六进制:`0-9&A(10)-F(15)`;以`0x`或`0X`开头，A-F不区分大小写,`int n = 0x10101;`
## 2.进制的转换*
### 2.1 2，8，16转成十进制
* 二进制->十进制：从最右位开始，将每个位上的数提取出来，乘以2的（位数-1）次方，然后求和
* 八进制->十进制：\~乘以8的（位数-1）次方\~
* 十六进制->十进制：\~乘以16的（位数-1）次方\~

````java
0b1011 => 1*2^0 + 1*2^1 + 0*2^2 + 1*2^3 = 11
01011 =>  1*8^0 + 1*8^1 + 0*8^2 + 1*8^3 = 521
0xAE78 => 8*16^0 + 7*16^1 + 14*16^2 + 10*16^3 = 44664
````
### 2.2 十进制转出2，8，16
* 十进制->二进制: 将这个数不断除以2，直到商为0，然后将每步得到的余数倒过来，就是对应的二进制
* 十进制->八进制: 将这个数不断除以8~
* 十进制->十六进制: 将这个数不断除以16~
```java
34 => 34/2 = 17……0
      17/2 = 8……1
      8/2 = 4……0     => 0b100010 =>字节(八位)0b00100010
      4/2 = 2……0
      2/2 = 1……0
      1/2 = 0……1

131 => 131/8 = 16 ……3
       16/8 = 2……0      => 0203 
       2/8 = 0……2

237 => 237/16 = 14 ……D(13)  => 0xED
    => 14/16 = 0……E(14)

```
### 2.3 二进制转出8，16
* 二进制->八进制: 将二进制数每3位一组`(000~111=>0~7)`，形成对应的八进制数
* 二进制->十六进制: 将二进制数每4位一组`(0000~1111=>0~15)`，形成对应的十六进制数

````java
0b11010101 => 11(3)010(2)101(5) => 0325
0b11010101 => 1101(13)0101(5) => 0xD5
````
### 2.4 8，16转成二进制
* 八进制->二进制: 将八进制数每1位，转成对应的3位的二进制数
* 十六进制->二进制: 将十六进制数每1位，转成对应的4位的二进制数
````java
0237 => 2(010)3(011)7(111) => 0b010011111 => (字节时省略多余的0)0b10011111
0x23B => 2(0010)3(0011)B(1011) => 0b001000111011
````


## 3. 二进制的原码、反码、补码*
### 3.1 有符号的
* 二进制的最高位是**符号位**：`0`为正,`1`为负
* 正数三码相同
* 负数的反码 = 原码符号位不变，其他位取反(`0->1,1->0`)
* 负数的补码 = 反码+1
* 0的反码和补码都是0
* java中的数都是有符号的
* **计算机都是以补码的方式进行运算的**(统一正负数)
* 看运算结果时，要看**原码**

## 4. 位运算

`&,|,^,~,>>,<<,>>>`
* 按位与`&`：两位全为1，结果为1，否则为0
* 按位或`|`：两位全为0，结果为0，否则为1
* 按位异或`^`：两位相同结果为0，否则为1
* 按位取反`~`：`0->1,1->0`
* 算数右移`>>`:低位溢出，符号位不变，并用符号位补溢出的高位
* 算数左移`<<`:符号位不变，低位补0
* 逻辑右移(无符号右移)`>>>`:低位溢出，高位补0
````java
//计算2&3
//Step1: 2的补码 = 2的原码(正数三码相同) = 00000000 00000000 00000000 00000010 (int 4字节)
//Step2: 3的补码 = 3的原码 =  00000000 00000000 00000000 00000011 (int 4字节)
//Step3: 按位与&
//        00000000 00000000 00000000 00000010 (2的补码)
//        00000000 00000000 00000000 00000011 (3的补码)
//   =    00000000 00000000 00000000 00000010 (运算后的补码)
//     => 符号位为0,所以运算后的原码
//         = 补码 00000000 00000000 00000000 00000010(运算后的原码) 
//         = 2

1>>2 = ;//向右位移2位 00000000 00000000 00000000 00000001 => 00000000 00000000 00000000 00000000 (本质 1/2/2 = 0)
-1<<2 = ;//向左位移2位 10000000 00000000 00000000 00000001 => 10000000 00000000 00000000 00000100 (本质 -1*2*2 = -4)
5>>>2 = ;//逻辑右移2位
~2 = ;//按位取反
~-5 = ;
2&3 = ;//按位与
13&7 = ;
2|3 = ;//按位或
5|4 = ;
-3^3 = ;//按位异或
````



